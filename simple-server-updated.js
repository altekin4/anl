const http = require('http');
const fs = require('fs');
const path = require('path');

// Load environment variables
try {
  require('dotenv').config();
} catch (error) {
  console.log('dotenv not installed, using environment variables');
}

// Load Y√ñK Atlas data (2024 g√ºncel)
let universitiesData = [];
let departmentsData = [];
let scoresData = [];
let futureCareersData = [];
let comprehensiveUniversitiesData = [];

try {
  universitiesData = JSON.parse(fs.readFileSync('./data/universities.json', 'utf8'));
  departmentsData = JSON.parse(fs.readFileSync('./data/departments.json', 'utf8'));
  scoresData = JSON.parse(fs.readFileSync('./data/scores.json', 'utf8'));
  futureCareersData = JSON.parse(fs.readFileSync('./data/future-careers.json', 'utf8'));
  comprehensiveUniversitiesData = JSON.parse(fs.readFileSync('./data/comprehensive-universities.json', 'utf8'));
  console.log('‚úÖ 2024 Y√ñK Atlas verileri y√ºklendi:', {
    universities: universitiesData.length,
    departments: departmentsData.length,
    scores: scoresData.length,
    futureCareers: futureCareersData.length,
    comprehensiveUniversities: comprehensiveUniversitiesData.length
  });
} catch (error) {
  console.log('‚ö†Ô∏è  Y√ñK Atlas verileri y√ºklenemedi, mock veriler kullanƒ±lacak:', error.message);
}

// Polyfill for fetch in Node.js
const fetch = (...args) => import('node-fetch').then(({ default: fetch }) => fetch(...args));

const PORT = 3005;

// MIME types
const mimeTypes = {
  '.html': 'text/html',
  '.css': 'text/css',
  '.js': 'application/javascript',
  '.json': 'application/json',
  '.png': 'image/png',
  '.jpg': 'image/jpeg',
  '.gif': 'image/gif',
  '.svg': 'image/svg+xml',
  '.ico': 'image/x-icon'
};

const server = http.createServer(async (req, res) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.url}`);

  const url = req.url;

  // Enable CORS
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, x-user-id');

  if (req.method === 'OPTIONS') {
    res.writeHead(200);
    res.end();
    return;
  }

  // API Routes
  if (url === '/api/chat/sessions' && req.method === 'POST') {
    console.log('üìù Session creation endpoint hit');
    res.writeHead(201, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({
      success: true,
      data: {
        sessionId: 'mock-session-' + Date.now(),
        userId: 'mock-user',
        createdAt: new Date().toISOString(),
        isActive: true
      }
    }));
    return;
  }

  if (url.includes('/messages') && req.method === 'POST') {
    console.log('üì® Messages endpoint hit:', url);
    let body = '';
    req.on('data', chunk => {
      body += chunk.toString();
    });

    req.on('end', async () => {
      console.log('üì¶ Message body:', body);
      try {
        const data = JSON.parse(body);
        const response = await generateResponse(data.content);

        res.writeHead(200, { 'Content-Type': 'application/json; charset=utf-8' });
        res.end(JSON.stringify({
          success: true,
          data: {
            userMessage: {
              content: data.content,
              type: 'user',
              timestamp: new Date().toISOString()
            },
            botMessage: {
              content: response.message,
              type: 'bot',
              timestamp: new Date().toISOString(),
              metadata: {
                intent: response.intent,
                entities: response.entities
              }
            },
            message: response.message,
            intent: response.intent,
            entities: response.entities,
            suggestions: response.suggestions
          }
        }));
      } catch (error) {
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
          success: false,
          error: {
            code: 'PROCESSING_ERROR',
            message: 'Mesaj i≈ülenirken hata olu≈ütu'
          }
        }));
      }
    });
    return;
  }

  // Base scores by department endpoint
  if (url === '/api/base-scores' && req.method === 'POST') {
    let body = '';
    req.on('data', chunk => {
      body += chunk.toString();
    });

    req.on('end', async () => {
      try {
        const data = JSON.parse(body);
        const results = getBaseScoresByDepartment(data.department, data.scoreType, data.userScore);

        res.writeHead(200, { 'Content-Type': 'application/json; charset=utf-8' });
        res.end(JSON.stringify({
          success: true,
          data: {
            department: data.department,
            scoreType: data.scoreType,
            userScore: data.userScore,
            universities: results,
            totalFound: results.length
          }
        }));
      } catch (error) {
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
          success: false,
          error: {
            code: 'PROCESSING_ERROR',
            message: 'Taban puan sorgusu i≈ülenirken hata olu≈ütu'
          }
        }));
      }
    });
    return;
  }

  // University recommendations by score endpoint
  if (url === '/api/university-recommendations' && req.method === 'POST') {
    let body = '';
    req.on('data', chunk => {
      body += chunk.toString();
    });

    req.on('end', async () => {
      try {
        const data = JSON.parse(body);
        const recommendations = getUniversityRecommendationsByScore(data.userScore, data.scoreType, data.department);

        res.writeHead(200, { 'Content-Type': 'application/json; charset=utf-8' });
        res.end(JSON.stringify({
          success: true,
          data: {
            userScore: data.userScore,
            scoreType: data.scoreType,
            department: data.department,
            recommendations: recommendations,
            totalRecommendations: recommendations.safe.length + recommendations.target.length + recommendations.risky.length
          }
        }));
      } catch (error) {
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
          success: false,
          error: {
            code: 'PROCESSING_ERROR',
            message: '√úniversite √∂nerisi olu≈üturulurken hata olu≈ütu'
          }
        }));
      }
    });
    return;
  }

  // Future careers recommendation endpoint
  if (url === '/api/career-recommendation' && req.method === 'POST') {
    let body = '';
    req.on('data', chunk => {
      body += chunk.toString();
    });

    req.on('end', async () => {
      try {
        const data = JSON.parse(body);
        const recommendation = generateCareerRecommendation(data.tytNet, data.aytNet, data.scoreType);

        res.writeHead(200, { 'Content-Type': 'application/json; charset=utf-8' });
        res.end(JSON.stringify({
          success: true,
          data: recommendation
        }));
      } catch (error) {
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
          success: false,
          error: {
            code: 'PROCESSING_ERROR',
            message: 'Kariyer √∂nerisi olu≈üturulurken hata olu≈ütu'
          }
        }));
      }
    });
    return;
  }

  // General chat endpoint (fallback)
  if (url.startsWith('/api/chat') && req.method === 'POST') {
    let body = '';
    req.on('data', chunk => {
      body += chunk.toString();
    });

    req.on('end', async () => {
      try {
        const data = JSON.parse(body);
        const response = await generateResponse(data.message);

        res.writeHead(200, { 'Content-Type': 'application/json; charset=utf-8' });
        res.end(JSON.stringify({
          success: true,
          content: response.message,
          intent: response.intent,
          entities: response.entities,
          suggestions: response.suggestions
        }));
      } catch (error) {
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
          success: false,
          error: {
            code: 'INVALID_JSON',
            message: 'Ge√ßersiz JSON formatƒ±'
          }
        }));
      }
    });
    return;
  }

  // Static file serving
  let filePath = path.join(__dirname, 'public', url === '/' ? 'index.html' : url);

  // Security check
  if (!filePath.startsWith(path.join(__dirname, 'public'))) {
    res.writeHead(403, { 'Content-Type': 'text/plain' });
    res.end('Forbidden');
    return;
  }

  try {
    const stats = fs.statSync(filePath);

    if (stats.isFile()) {
      const ext = path.extname(filePath);
      const contentType = mimeTypes[ext] || 'application/octet-stream';

      res.writeHead(200, { 'Content-Type': contentType });
      fs.createReadStream(filePath).pipe(res);
    } else {
      res.writeHead(404, { 'Content-Type': 'text/plain' });
      res.end('File not found');
    }
  } catch (error) {
    res.writeHead(404, { 'Content-Type': 'text/plain' });
    res.end('File not found');
  }
});

// AI Response Generation - Anthropic Claude with 2024 data
async function generateResponse(userMessage) {
  // √ñnce OpenAI'yi deneyelim (daha stabil)
  try {
    console.log('ü§ñ Using OpenAI GPT for response generation');
    const openaiResponse = await generateOpenAIResponse(userMessage);
    if (openaiResponse) {
      return openaiResponse;
    }
  } catch (error) {
    console.error('‚ùå OpenAI API Error:', error.message);
  }

  // Anthropic'i backup olarak kullan
  try {
    console.log('üîÑ Falling back to Anthropic Claude');
    const anthropicResponse = await generateAnthropicResponse(userMessage);
    if (anthropicResponse) {
      return anthropicResponse;
    }
  } catch (error) {
    console.error('‚ùå Anthropic API Error:', error.message);
  }

  return {
    intent: 'error',
    entities: {},
    message: `√úzg√ºn√ºm, ≈üu anda AI servislerimizde teknik sorun ya≈üƒ±yoruz. L√ºtfen daha sonra tekrar deneyin.`,
    suggestions: ['Tekrar deneyin', 'Daha sonra tekrar gelin'],
    source: 'error'
  };
}

async function generateAnthropicResponse(userMessage) {
  const apiKey = process.env.ANTHROPIC_API_KEY;

  console.log('üîç Checking Anthropic API key:', apiKey ? `Present (${apiKey.substring(0, 20)}...)` : 'Missing');

  if (!apiKey || apiKey === 'your_anthropic_api_key_here') {
    console.log('‚ùå Anthropic API key not configured');
    return null;
  }

  try {
    console.log('ü§ñ Trying Anthropic Claude API with message:', userMessage.substring(0, 50) + '...');
    console.log('üîë API Key length:', apiKey.length);
    console.log('üîë API Key starts with:', apiKey.substring(0, 15));
    
    const requestBody = {
      model: process.env.ANTHROPIC_MODEL || 'claude-3-haiku-20240307',
      max_tokens: parseInt(process.env.ANTHROPIC_MAX_TOKENS || '500'),
      messages: [
        {
          role: 'user',
          content: `Sen "Tercih Sihirbazƒ±" adlƒ± bir AI asistanƒ±sƒ±n. T√ºrkiye'deki lise √∂ƒürencilerine √ºniversite tercih s√ºrecinde yardƒ±mcƒ± oluyorsun.

G√úNCEL VERƒ∞LER (2024):
- 15 √ºniversite, farklƒ± seviyelerden (√úst, Orta-√úst, Orta, Orta-Alt)
- Taban puanlarƒ± √ºniversite bazƒ±nda detaylƒ±

√úST SEVƒ∞YE √úNƒ∞VERSƒ∞TELER:
- ƒ∞T√ú Bilgisayar: SAY 545 puan (8.5K sƒ±ralama)
- Boƒüazi√ßi Bilgisayar: SAY 550 puan (7.5K sƒ±ralama)
- ODT√ú Bilgisayar: SAY 540 puan (9.5K sƒ±ralama)

ORTA SEVƒ∞YE √úNƒ∞VERSƒ∞TELER:
- Gazi Bilgisayar: SAY 505 puan (25K sƒ±ralama)
- Marmara Bilgisayar: SAY 510 puan (22K sƒ±ralama)
- YT√ú Bilgisayar: SAY 495 puan (30K sƒ±ralama)

ORTA-ALT SEVƒ∞YE √úNƒ∞VERSƒ∞TELER:
- Sakarya Bilgisayar: SAY 475 puan (42K sƒ±ralama)
- Kocaeli Bilgisayar: SAY 470 puan (45K sƒ±ralama)
- ESOG√ú Bilgisayar: SAY 460 puan (52K sƒ±ralama)

GELECEƒûƒ∞ PARLAK MESLEKLER (2024-2030):
1. Yapay Zeka M√ºhendisliƒüi (%300 b√ºy√ºme, 25-50K TL maa≈ü)
2. Siber G√ºvenlik M√ºhendisliƒüi (%250 b√ºy√ºme, 20-40K TL maa≈ü)
3. Veri Bilimi (%200 b√ºy√ºme, 18-35K TL maa≈ü)
4. Biyomedikal M√ºhendisliƒüi (%180 b√ºy√ºme, 15-30K TL maa≈ü)
5. Yenilenebilir Enerji M√ºhendisliƒüi (%170 b√ºy√ºme, 14-28K TL maa≈ü)
6. Oyun Tasarƒ±mƒ± ve Programlama (%160 b√ºy√ºme, 15-35K TL maa≈ü)
7. √áevre M√ºhendisliƒüi (%150 b√ºy√ºme, 12-25K TL maa≈ü)
8. Dijital Pazarlama (%140 b√ºy√ºme, 10-25K TL maa≈ü)
9. UX/UI Tasarƒ±m (%130 b√ºy√ºme, 12-30K TL maa≈ü)
10. Psikoloji (Klinik) (%120 b√ºy√ºme, 8-20K TL maa≈ü)

G√ñREVLER:
1. TYT/AYT net hesaplamalarƒ± (Doƒüru - Yanlƒ±≈ü/4 form√ºl√º)
2. √úniversite ve b√∂l√ºm bilgileri (2024 g√ºncel)
3. Taban puan bilgileri (2024 Y√ñK Atlas verileri)
4. Tercih stratejileri ve tavsiyeleri
5. Ba≈üarƒ±lƒ± √∂ƒürencilerden motivasyon hikayeleri
6. GELECEƒûƒ∞ PARLAK MESLEKLER √ñNERƒ∞Sƒ∞ (net sayƒ±sƒ±na g√∂re)

YANIT KURALLARI:
- Sadece T√ºrk√ße yanƒ±t ver
- Samimi, destekleyici ve motive edici ol
- Net hesaplamalarƒ±nda kesin form√ºl kullan: Net = Doƒüru - (Yanlƒ±≈ü √∑ 4)
- TYT: T√ºrk√ße(40), Matematik(40), Fen(20), Sosyal(20) soru
- AYT SAY: Matematik(40), Fizik(14), Kimya(13), Biyoloji(13) soru
- 2024 g√ºncel verilerini kullan
- Geleceƒüi parlak meslekleri √∂ner
- Net sayƒ±sƒ±na g√∂re uygun b√∂l√ºmleri √∂ner
- Emoji kullan ama abartma
- Kƒ±sa ve √∂z yanƒ±tlar ver
- √ñrnekler ver

√ñZEL DURUMLAR:
- Net hesaplama sorularƒ±nda mutlaka hesaplama yap
- Taban puan sorularƒ±nda MUTLAKA √ºniversite adƒ±nƒ± belirt
- Farklƒ± seviyedeki √ºniversiteleri (√ºst, orta, orta-alt) √∂ner
- Kullanƒ±cƒ±nƒ±n puanƒ±na g√∂re g√ºvenli/hedef/riskli tercihler √∂ner
- B√∂l√ºm sorularƒ±nda i≈ü imkanlarƒ±ndan ve gelecek potansiyelinden bahset
- √áalƒ±≈üma tavsiyesi sorularƒ±nda ba≈üarƒ±lƒ± √∂ƒürenci hikayeleri payla≈ü
- "Geleceƒüi parlak meslekler" sorularƒ±nda yukarƒ±daki listeyi kullan
- Net sayƒ±sƒ± verildiƒüinde uygun b√∂l√ºmleri ve √ºniversiteleri √∂ner

Kullanƒ±cƒ± mesajƒ±: "${userMessage}"`
        }
      ]
    };

    console.log('üì§ Request body model:', requestBody.model);
    console.log('üì§ Request body max_tokens:', requestBody.max_tokens);

    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'x-api-key': apiKey,
        'Content-Type': 'application/json',
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify(requestBody)
    });

    if (response.ok) {
      const data = await response.json();
      const aiMessage = data.content[0].text;

      console.log('‚úÖ Anthropic response received');

      const intent = classifyIntent(userMessage);
      const entities = extractEntities(userMessage);
      const suggestions = generateSuggestions(intent);

      return {
        intent,
        entities,
        message: aiMessage,
        suggestions,
        source: 'anthropic'
      };
    } else {
      const error = await response.json();
      console.log('‚ùå Anthropic API Error:', error);
      throw new Error(`Anthropic API Error: ${error.error?.message || 'Unknown error'}`);
    }
  } catch (error) {
    console.log('üí• Anthropic Request Error:', error.message);
    throw error;
  }
}

function classifyIntent(message) {
  const lowerMessage = message.toLowerCase();

  if (lowerMessage.includes('merhaba') || lowerMessage.includes('selam') ||
    lowerMessage.includes('hello') || lowerMessage.includes('hi')) {
    return 'greeting';
  }

  if (lowerMessage.includes('te≈üekk√ºr') || lowerMessage.includes('saƒüol')) {
    return 'thanks';
  }

  if (lowerMessage.includes('tyt')) {
    return 'tyt_calculation';
  }

  if (lowerMessage.includes('ayt')) {
    return 'ayt_calculation';
  }

  if (lowerMessage.includes('tavsiye') || lowerMessage.includes('ba≈üarƒ±lƒ± √∂ƒürenci') ||
    lowerMessage.includes('motivasyon') || lowerMessage.includes('√ßalƒ±≈üma y√∂ntemi')) {
    return 'study_advice';
  }

  if (lowerMessage.includes('taban puan') || 
    (lowerMessage.includes('taban') && lowerMessage.includes('puan'))) {
    return 'base_score';
  }

  if (lowerMessage.includes('b√∂l√ºm') || lowerMessage.includes('m√ºhendislik')) {
    return 'department_search';
  }

  if (lowerMessage.includes('√ºniversite hakkƒ±nda') ||
    lowerMessage.includes('√ºniversite bilgi')) {
    return 'university_info';
  }

  // Career recommendation patterns
  if (lowerMessage.includes('geleceƒüi parlak') || lowerMessage.includes('gelecek meslek') ||
    lowerMessage.includes('kariyer √∂ner') || lowerMessage.includes('meslek √∂ner') ||
    lowerMessage.includes('hangi b√∂l√ºm oku') || lowerMessage.includes('ne okumalƒ±') ||
    lowerMessage.includes('i≈ü imkanƒ±') || lowerMessage.includes('maa≈ü y√ºksek')) {
    return 'career_recommendation';
  }

  if (lowerMessage.includes('net') || lowerMessage.includes('hesap') ||
    lowerMessage.includes('doƒüru') || lowerMessage.includes('yanlƒ±≈ü')) {
    return 'tyt_calculation';
  }

  return 'general';
}

function extractEntities(message) {
  const entities = {};
  const lowerMessage = message.toLowerCase();

  const universities = ['it√º', 'odt√º', 'boƒüazi√ßi', 'marmara', 'istanbul', 'ankara'];
  for (const uni of universities) {
    if (lowerMessage.includes(uni)) {
      entities.university = uni.toUpperCase();
      break;
    }
  }

  const departments = ['bilgisayar', 'elektrik', 'makine', 'i≈ületme', 'hukuk', 'tƒ±p'];
  for (const dept of departments) {
    if (lowerMessage.includes(dept)) {
      entities.department = dept;
      break;
    }
  }

  const numbers = message.match(/\d+/g);
  if (numbers) {
    entities.numbers = numbers.map(n => parseInt(n));
  }

  return entities;
}

function generateSuggestions(intent) {
  const suggestions = {
    'tyt_calculation': ['AYT hesaplama yap', 'TYT √ßalƒ±≈üma planƒ±', 'Hedef √ºniversiteler'],
    'ayt_calculation': ['TYT hesaplama yap', 'AYT √ßalƒ±≈üma planƒ±', 'B√∂l√ºm √∂nerileri'],
    'study_advice': ['√áalƒ±≈üma y√∂ntemi', 'Zaman y√∂netimi', 'Motivasyon'],
    'base_score': ['Kontenjan bilgisi', 'Benzer b√∂l√ºmler', '2024 kar≈üƒ±la≈ütƒ±rmasƒ±'],
    'greeting': ['TYT netimi hesapla', 'AYT hesaplama yap', 'Geleceƒüi parlak meslekler'],
    'general': ['TYT netimi hesapla', 'AYT hesaplama', 'Geleceƒüi parlak meslekler']
  };

  return suggestions[intent] || suggestions['general'];
}

// Kariyer √∂nerisi fonksiyonu
function generateCareerRecommendation(tytNet, aytNet, scoreType = 'SAY') {
  console.log(`üéØ Generating career recommendation for TYT: ${tytNet}, AYT: ${aytNet}, Type: ${scoreType}`);
  
  const recommendations = [];
  
  // Net sayƒ±sƒ±na g√∂re uygun meslekleri filtrele
  futureCareersData.forEach(career => {
    const requiredTYT = career.requiredNets.TYT;
    const requiredAYT = career.requiredNets[`AYT_${scoreType}`] || career.requiredNets.AYT_SAY || 0;
    
    // Net sayƒ±sƒ± yeterli mi kontrol et
    if (tytNet >= requiredTYT - 10 && aytNet >= requiredAYT - 10) {
      const suitabilityScore = calculateSuitabilityScore(tytNet, aytNet, career);
      
      recommendations.push({
        ...career,
        suitabilityScore,
        netGap: {
          tyt: Math.max(0, requiredTYT - tytNet),
          ayt: Math.max(0, requiredAYT - aytNet)
        },
        recommendation: generateRecommendationText(career, tytNet, aytNet)
      });
    }
  });
  
  // Uygunluk skoruna g√∂re sƒ±rala
  recommendations.sort((a, b) => b.suitabilityScore - a.suitabilityScore);
  
  return {
    totalRecommendations: recommendations.length,
    topRecommendations: recommendations.slice(0, 5),
    userNets: { tyt: tytNet, ayt: aytNet, scoreType },
    message: generateCareerMessage(recommendations.slice(0, 3), tytNet, aytNet)
  };
}

function calculateSuitabilityScore(tytNet, aytNet, career) {
  const requiredTYT = career.requiredNets.TYT;
  const requiredAYT = career.requiredNets.AYT_SAY || 0;
  
  // Net fazlalƒ±ƒüƒ± bonus puanƒ±
  const tytBonus = Math.max(0, tytNet - requiredTYT) * 2;
  const aytBonus = Math.max(0, aytNet - requiredAYT) * 2;
  
  // Gelecek skoru
  const futureScore = career.futureScore;
  
  return futureScore + tytBonus + aytBonus;
}

function generateRecommendationText(career, tytNet, aytNet) {
  const requiredTYT = career.requiredNets.TYT;
  const requiredAYT = career.requiredNets.AYT_SAY || 0;
  
  let text = `${career.department} - ${career.category}\n`;
  text += `üí∞ Maa≈ü: ${career.averageSalary}\n`;
  text += `üìà B√ºy√ºme: ${career.jobGrowth}\n`;
  
  if (tytNet >= requiredTYT && aytNet >= requiredAYT) {
    text += `‚úÖ Net sayƒ±n yeterli! G√ºvenle tercih edebilirsin.\n`;
  } else {
    const tytGap = Math.max(0, requiredTYT - tytNet);
    const aytGap = Math.max(0, requiredAYT - aytNet);
    if (tytGap > 0) text += `üìö TYT'de ${tytGap} net daha yapmalƒ±sƒ±n\n`;
    if (aytGap > 0) text += `üìö AYT'de ${aytGap} net daha yapmalƒ±sƒ±n\n`;
  }
  
  return text;
}

function generateCareerMessage(topCareers, tytNet, aytNet) {
  if (topCareers.length === 0) {
    return `üéØ **Kariyer √ñnerisi**\n\nMevcut net sayƒ±larƒ±nla (TYT: ${tytNet}, AYT: ${aytNet}) hen√ºz geleceƒüi parlak mesleklere y√∂nelik √∂nerimiz yok. Biraz daha √ßalƒ±≈üarak net sayƒ±larƒ±nƒ± artƒ±rabilirsin!\n\nüí™ Hedef: TYT 60+ net, AYT 50+ net`;
  }
  
  let message = `üéØ **Geleceƒüi Parlak Meslekler - Ki≈üisel √ñneriler**\n\n`;
  message += `üìä **Mevcut Netlerin:** TYT ${tytNet}, AYT ${aytNet}\n\n`;
  
  topCareers.forEach((career, index) => {
    message += `${index + 1}. **${career.department}**\n`;
    message += `   üí∞ Maa≈ü: ${career.averageSalary}\n`;
    message += `   üìà B√ºy√ºme: ${career.jobGrowth}\n`;
    message += `   üéØ Gerekli Net: TYT ${career.requiredNets.TYT}, AYT ${career.requiredNets.AYT_SAY || 0}\n`;
    
    if (career.netGap.tyt > 0 || career.netGap.ayt > 0) {
      message += `   üìö Eksik: `;
      if (career.netGap.tyt > 0) message += `TYT ${career.netGap.tyt} net `;
      if (career.netGap.ayt > 0) message += `AYT ${career.netGap.ayt} net`;
      message += `\n`;
    } else {
      message += `   ‚úÖ Net sayƒ±n yeterli!\n`;
    }
    message += `\n`;
  });
  
  return message;
}

// Taban puan sorgulama fonksiyonu
function getBaseScoresByDepartment(departmentName, scoreType = 'SAY', userScore = null) {
  console.log(`üîç Searching base scores for: ${departmentName}, Type: ${scoreType}, User Score: ${userScore}`);
  
  const results = [];
  
  comprehensiveUniversitiesData.forEach(university => {
    const departments = university.departments;
    
    // B√∂l√ºm adƒ±nƒ± esnek arama ile bul
    const matchingDept = Object.keys(departments).find(dept => 
      dept.toLowerCase().includes(departmentName.toLowerCase()) ||
      departmentName.toLowerCase().includes(dept.toLowerCase())
    );
    
    if (matchingDept && departments[matchingDept][scoreType]) {
      const deptData = departments[matchingDept][scoreType];
      
      results.push({
        university: university.name,
        shortName: university.shortName,
        city: university.city,
        tier: university.tier,
        ranking: university.ranking,
        department: matchingDept,
        scoreType: scoreType,
        baseScore: deptData.baseScore,
        quota: deptData.quota,
        rank: deptData.rank,
        isReachable: userScore ? userScore >= deptData.baseScore : null,
        scoreDifference: userScore ? userScore - deptData.baseScore : null
      });
    }
  });
  
  // Taban puana g√∂re sƒ±rala (en y√ºksekten en d√º≈ü√ºƒüe)
  results.sort((a, b) => b.baseScore - a.baseScore);
  
  return results;
}

// Kullanƒ±cƒ±nƒ±n puanƒ±na g√∂re uygun √ºniversiteleri √∂ner
function getUniversityRecommendationsByScore(userScore, scoreType = 'SAY', departmentName = null) {
  console.log(`üéØ Getting recommendations for score: ${userScore}, Type: ${scoreType}, Department: ${departmentName}`);
  
  const recommendations = {
    safe: [], // G√ºvenli tercihler (kullanƒ±cƒ± puanƒ± > taban puanƒ± + 20)
    target: [], // Hedef tercihler (kullanƒ±cƒ± puanƒ± > taban puanƒ± + 5)
    risky: [] // Riskli tercihler (kullanƒ±cƒ± puanƒ± > taban puanƒ± - 5)
  };
  
  comprehensiveUniversitiesData.forEach(university => {
    const departments = university.departments;
    
    Object.keys(departments).forEach(deptName => {
      // Eƒüer belirli bir b√∂l√ºm aranƒ±yorsa filtrele
      if (departmentName && !deptName.toLowerCase().includes(departmentName.toLowerCase())) {
        return;
      }
      
      const deptData = departments[deptName][scoreType];
      if (!deptData) return;
      
      const scoreDiff = userScore - deptData.baseScore;
      
      const recommendation = {
        university: university.name,
        shortName: university.shortName,
        city: university.city,
        tier: university.tier,
        ranking: university.ranking,
        department: deptName,
        baseScore: deptData.baseScore,
        quota: deptData.quota,
        rank: deptData.rank,
        scoreDifference: scoreDiff,
        probability: calculateAdmissionProbability(scoreDiff)
      };
      
      if (scoreDiff >= 20) {
        recommendations.safe.push(recommendation);
      } else if (scoreDiff >= 5) {
        recommendations.target.push(recommendation);
      } else if (scoreDiff >= -5) {
        recommendations.risky.push(recommendation);
      }
    });
  });
  
  // Her kategoriyi taban puana g√∂re sƒ±rala
  recommendations.safe.sort((a, b) => b.baseScore - a.baseScore);
  recommendations.target.sort((a, b) => b.baseScore - a.baseScore);
  recommendations.risky.sort((a, b) => b.baseScore - a.baseScore);
  
  return recommendations;
}

function calculateAdmissionProbability(scoreDifference) {
  if (scoreDifference >= 20) return 95;
  if (scoreDifference >= 10) return 85;
  if (scoreDifference >= 5) return 75;
  if (scoreDifference >= 0) return 60;
  if (scoreDifference >= -5) return 40;
  if (scoreDifference >= -10) return 25;
  return 10;
}

server.listen(PORT, () => {
  console.log('‚úÖ 2024 Y√ñK Atlas verileri y√ºklendi:', {
    universities: universitiesData.length,
    departments: departmentsData.length,
    scores: scoresData.length
  });
  console.log('üöÄ Tercih Sihirbazƒ± sunucusu ba≈ülatƒ±ldƒ±! (2024 G√ºncel)');
  console.log('üåê URL: http://localhost:' + PORT);
  console.log('üîó Tarayƒ±cƒ±nƒ±zda http://localhost:' + PORT + ' adresini a√ßƒ±n');
  console.log('üìÅ Dosyalar: ' + __dirname + '/public');
  console.log('‚è∞ Ba≈ülatma zamanƒ±: ' + new Date().toLocaleString('tr-TR'));
  console.log('');
  console.log('üìä Mevcut √∂zellikler:');
  console.log('  ‚úÖ Static dosya servisi');
  console.log('  ‚úÖ Anthropic Claude API (2024 g√ºncel veriler)');
  console.log('  ‚úÖ Chat interface');
  console.log('  ‚úÖ Responsive tasarƒ±m');
  console.log('  ‚úÖ 2024 Y√ñK Atlas verileri');

});

async function generateOpenAIResponse(userMessage) {
  const apiKey = process.env.OPENAI_API_KEY;

  if (!apiKey || apiKey === 'demo-key') {
    console.log('OpenAI API key not configured');
    return null;
  }

  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-3.5-turbo',
        messages: [
          {
            role: 'system',
            content: `Sen Tercih Sihirbazƒ±'sƒ±n, T√ºrkiye'deki √ºniversite tercih s√ºrecinde √∂ƒürencilere yardƒ±mcƒ± olan bir AI asistanƒ±sƒ±n. 

2024 G√úNCEL VERƒ∞LER:
- Bilgisayar M√ºhendisliƒüi: SAY 535, EA 525 puan
- Makine M√ºhendisliƒüi: SAY 520, EA 510 puan
- ƒ∞≈ületme: SAY 495, EA 485 puan
- Tƒ±p: SAY 565, EA 555 puan

G√∂revlerin:
- √úniversite ve b√∂l√ºm bilgileri vermek (2024 g√ºncel)
- Net hesaplama yardƒ±mƒ± yapmak
- Tercih stratejileri √∂nermek
- Taban puanlarƒ± hakkƒ±nda bilgi vermek

Yanƒ±t verirken:
- T√ºrk√ße kullan
- Samimi ve yardƒ±msever ol
- Kƒ±sa ve net yanƒ±tlar ver
- 2024 g√ºncel verilerini kullan
- √ñrnekler ver
- √ñƒürenciyi motive et`
          },
          {
            role: 'user',
            content: userMessage
          }
        ],
        max_tokens: 300,
        temperature: 0.7
      })
    });

    if (response.ok) {
      const data = await response.json();
      const aiMessage = data.choices[0].message.content;

      const intent = classifyIntent(userMessage);
      const entities = extractEntities(userMessage);
      const suggestions = generateSuggestions(intent);

      return {
        intent,
        entities,
        message: aiMessage,
        suggestions,
        source: 'openai'
      };
    } else {
      const error = await response.json();
      console.log('OpenAI API Error:', error);
      throw new Error(`OpenAI API Error: ${error.error?.message || 'Unknown error'}`);
    }
  } catch (error) {
    console.log('OpenAI Request Error:', error.message);
    throw error;
  }
}